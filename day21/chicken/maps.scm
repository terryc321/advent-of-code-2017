
#|
purpose of seperator /
well know either 2 x 2 matrix
OR 3 x 3 matrix , so we can remove / slash

0 means off
1 means on

|#


(define (convert-char ch)
  (cond
   ((char=? ch #\.) 0)
   ((char=? ch #\#) 1)
   (#t (error "convert-char"))))

(define (convert s)
  (let ((slen (string-length s)))
    (cond
     ((= slen 5) (map convert-char (map (lambda (i) (string-ref s i)) '(0 1 3 4))))
     ((= slen 11) (map convert-char (map (lambda (i) (string-ref s i)) '(0 1 2
								       4 5 6
								       8 9 10))))
     ((= slen 19) (map convert-char (map (lambda (i) (string-ref s i))
				     '(0 1 2 3
					 5 6 7 8
					 10 11 12 13
					 15 16 17 18))))
     (#t (error "convert")))))

(define example2-map
  '(
    ("../.#" "##./#../...")
    ))

(define example3-map
  '(
    (".#./..#/###" "#..#/..../..../#..#")
    ))


(define input2-map
  '(
    ("../.." ".../#.#/...")
    ("#./.." "..#/..#/#..")
    ("##/.." ".../#../..#")
    (".#/#." "#../.../...")
    ("##/#." "#.#/.#./#..")
    ("##/##" "..#/#.#/..#")
    ))

(define input3-map
  '(
    (".../.../..." ".#../#..#/#.../.#..")
    ("#../.../..." "..##/..##/.#.#/....")
    (".#./.../..." "..##/..##/.###/##..")
    ("##./.../..." "..../.##./#.##/..#.")
    ("#.#/.../..." "####/#.##/#.##/#.#.")
    ("###/.../..." "#..#/..#./..../##.#")
    (".#./#../..." "..#./.#../...#/#.##")
    ("##./#../..." "..../#.##/#..#/.#..")
    ("..#/#../..." "##.#/####/###./###.")
    ("#.#/#../..." "..../#.##/.###/#.#.")
    (".##/#../..." "..#./##.#/####/..##")
    ("###/#../..." "..#./.##./...#/..#.")
    (".../.#./..." ".###/#.../.#../####")
    ("#../.#./..." "###./.#.#/#.##/##.#")
    (".#./.#./..." "..##/..#./###./..#.")
    ("##./.#./..." "#..#/..#./###./...#")
    ("#.#/.#./..." "#.../##.#/#.##/#..#")
    ("###/.#./..." "...#/#..#/####/##.#")
    (".#./##./..." "#.##/#.##/..../#.#.")
    ("##./##./..." "..##/###./..#./####")
    ("..#/##./..." "..../##../##.#/.##.")
    ("#.#/##./..." "##../####/####/.#.#")
    (".##/##./..." "..../##.#/.###/##..")
    ("###/##./..." ".#../#.#./.#../..##")
    (".../#.#/..." "####/#.#./..##/#..#")
    ("#../#.#/..." ".#../.#../#..#/....")
    (".#./#.#/..." "..##/.##./####/#.#.")
    ("##./#.#/..." "..#./###./.#../....")
    ("#.#/#.#/..." "..#./..#./...#/#...")
    ("###/#.#/..." "###./.#../##../####")
    (".../###/..." "#.##/####/####/..##")
    ("#../###/..." ".#.#/...#/###./...#")
    (".#./###/..." "..../.#.#/.#../....")
    ("##./###/..." "...#/.###/..../.##.")
    ("#.#/###/..." "..##/###./.#../#..#")
    ("###/###/..." ".###/..#./..#./.###")
    ("..#/.../#.." ".##./###./####/#.#.")
    ("#.#/.../#.." "####/#.../#.../..##")
    (".##/.../#.." "###./#..#/..#./.#..")
    ("###/.../#.." ".###/.##./#.#./.###")
    (".##/#../#.." "##.#/...#/.#.#/...#")
    ("###/#../#.." "#.##/..#./..../#..#")
    ("..#/.#./#.." "#..#/##.#/.##./####")
    ("#.#/.#./#.." "###./..##/#..#/#..#")
    (".##/.#./#.." ".#../..../...#/...#")
    ("###/.#./#.." ".#../##../.###/..#.")
    (".##/##./#.." "##../..##/##../##.#")
    ("###/##./#.." "#.##/#..#/.###/####")
    ("#../..#/#.." "##.#/####/#.../..##")
    (".#./..#/#.." "#..#/..../..../###.")
    ("##./..#/#.." "#..#/##.#/##.#/#.#.")
    ("#.#/..#/#.." ".###/##.#/####/#...")
    (".##/..#/#.." "####/.##./...#/#..#")
    ("###/..#/#.." ".#.#/####/##.#/...#")
    ("#../#.#/#.." "..##/.##./..##/##..")
    (".#./#.#/#.." "#.../##../..##/..#.")
    ("##./#.#/#.." "...#/##.#/#..#/.#..")
    ("..#/#.#/#.." "#.#./##../#.##/###.")
    ("#.#/#.#/#.." "##../##.#/#.#./....")
    (".##/#.#/#.." "####/...#/####/.#..")
    ("###/#.#/#.." "..../.#../.#../....")
    ("#../.##/#.." ".#.#/..#./#..#/.###")
    (".#./.##/#.." "#.../.#.#/.###/.##.")
    ("##./.##/#.." "#.#./#.#./.#../###.")
    ("#.#/.##/#.." "####/##../.##./####")
    (".##/.##/#.." "#.../#.#./#.##/###.")
    ("###/.##/#.." "####/####/..../####")
    ("#../###/#.." "####/.##./...#/##.#")
    (".#./###/#.." ".#../#.##/#..#/..##")
    ("##./###/#.." "#.#./..##/#.../..##")
    ("..#/###/#.." "#.##/.###/#.#./###.")
    ("#.#/###/#.." "#.##/#.##/..../#..#")
    (".##/###/#.." ".##./#.#./..##/####")
    ("###/###/#.." ".##./#..#/#.../###.")
    (".#./#.#/.#." "#.#./#..#/#..#/##.#")
    ("##./#.#/.#." "...#/#.#./##.#/###.")
    ("#.#/#.#/.#." "##.#/..##/##.#/#.##")
    ("###/#.#/.#." ".#.#/..#./##../.##.")
    (".#./###/.#." "#..#/..#./..##/#...")
    ("##./###/.#." "####/.#.#/####/..#.")
    ("#.#/###/.#." "#.#./..##/##../#..#")
    ("###/###/.#." "...#/..../..../#.#.")
    ("#.#/..#/##." "..#./.##./###./.#.#")
    ("###/..#/##." "#.../###./...#/####")
    (".##/#.#/##." "..../..../.###/##..")
    ("###/#.#/##." "##../..../#.#./.##.")
    ("#.#/.##/##." ".#.#/##../..##/#.#.")
    ("###/.##/##." "###./####/...#/.#..")
    (".##/###/##." "..##/#.../..##/.#.#")
    ("###/###/##." "..##/...#/.###/.#..")
    ("#.#/.../#.#" "..##/#.../##.#/....")
    ("###/.../#.#" "#.##/#..#/..../##..")
    ("###/#../#.#" "#.../..../##.#/..#.")
    ("#.#/.#./#.#" "###./..##/.#../.##.")
    ("###/.#./#.#" "..../#..#/.###/#..#")
    ("###/##./#.#" ".#.#/###./##.#/.###")
    ("#.#/#.#/#.#" "..../..../.##./#..#")
    ("###/#.#/#.#" ".###/.#.#/...#/.###")
    ("#.#/###/#.#" ".#.#/##../.#../.#..")
    ("###/###/#.#" ".#.#/.##./#.##/....")
    ("###/#.#/###" "..#./..#./..#./..##")
    ("###/###/###" "##.#/..##/.#.#/....")
    ))


;; vectors should be square matrices 2 x 2 ( 4 elems ), 3 x 3 ( 9 elems )or 4 x 4 ( 16 elems )
(define input-map (map (lambda (xy)
			 (let ((x (convert (car xy)))
			       (y (convert (cadr xy))))
			   (let ((xlen (length x))
				 (ylen (length y)))				 
			     (assert (member xlen '(4 9 16)))
			     (assert (member ylen '(4 9 16)))
			     (list x y))))
		       (append input2-map input3-map)))

(define example-map (map (lambda (xy)
			   (let ((x (convert (car xy)))
				 (y (convert (cadr xy))))
			     (let ((xlen (length x))
				   (ylen (length y)))				 
			       (assert (member xlen '(4 9 16)))
			       (assert (member ylen '(4 9 16)))
			       (list x y))))
			 (append example2-map example3-map)))


;; extend maps to cover all possible rotations and reflections
(define (extend-map m)
  (let ((result m))
    (dolist (pr m)
	    (let* ((from (car pr))
		   (to (cadr pr))
		   (possible (rotate-flip-permute from)))
	      (dolist (p possible)
		      (set! result (cons (list p to) result)))))
     result))


;; side effects only
(set! input-map (extend-map input-map))
(set! example-map (extend-map example-map))

;; convert lists to vec2d
(define (convert-map-to-vec2d m)
  (map (lambda (pr)
	 (let* ((from (list->vec2d (car pr)))
		(to (list->vec2d (cadr pr))))
	   (list from to)))
       m))


(set! input-map (convert-map-to-vec2d (extend-map input-map)))
(set! example-map (convert-map-to-vec2d (extend-map example-map)))


